<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wyoming LLC Filing Bot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
      html,
      body {
        font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
      }
      /* sticky table headers for wide result sets */
      .sticky-th th {
        position: sticky;
        top: 0;
        background: #f9fafb;
        z-index: 1;
      }
      /* multi-line clamp without Tailwind plugin */
      .clamp-2 {
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
    </style>
  </head>
  <body class="bg-gray-50 text-gray-900">
    <div class="max-w-6xl mx-auto p-6 space-y-6">
      <!-- Run guard banner -->
      <div
        id="runGuardBanner"
        class="hidden fixed top-0 left-0 right-0 z-50 bg-amber-100 border-b border-amber-300 text-amber-900"
      >
        <div
          class="max-w-6xl mx-auto px-4 py-2 text-sm flex items-center gap-2"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-4 w-4"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M10 18a8 8 0 100-16 8 8 0 000 16zM9 6h2v6H9V6zm0 8h2v2H9v-2z"
              clip-rule="evenodd"
            />
          </svg>
          <span>Run in progress. Do not close or reload this tab.</span>
        </div>
      </div>
      <!-- Header -->
      <header
        class="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between"
      >
        <div>
          <h1 class="text-2xl sm:text-3xl font-bold tracking-tight">
            Wyoming LLC Filing Bot
          </h1>
          <p class="text-gray-600">
            Upload a CSV, run the bot, and monitor progress.
          </p>
        </div>
        <div class="flex items-center gap-2">
          <span
            id="runStatus"
            class="inline-flex items-center rounded-full px-3 py-1 text-xs font-medium bg-gray-200 text-gray-700"
            >Idle</span
          >
        </div>
      </header>

      <!-- Controls -->
      <section
        class="bg-white border border-gray-200 rounded-xl shadow-sm p-4 sm:p-5"
      >
        <div
          class="flex flex-col sm:flex-row sm:items-center gap-3 justify-between"
        >
          <div class="flex items-center gap-3">
            <label
              for="fileCsv"
              class="inline-flex items-center gap-2 rounded-lg px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-900 cursor-pointer transition"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-4 w-4 opacity-80"
                viewBox="0 0 20 20"
                fill="currentColor"
              >
                <path
                  fill-rule="evenodd"
                  d="M3 16a2 2 0 002 2h10a2 2 0 002-2v-5a1 1 0 112 0v5a4 4 0 01-4 4H5a4 4 0 01-4-4V8a1 1 0 112 0v8z"
                  clip-rule="evenodd"
                />
                <path
                  fill-rule="evenodd"
                  d="M7 5a1 1 0 011-1h1V2a1 1 0 112 0v2h1a1 1 0 110 2h-1v2a1 1 0 11-2 0V6H8a1 1 0 01-1-1z"
                  clip-rule="evenodd"
                />
              </svg>
              <span>Upload CSV</span>
            </label>
            <input id="fileCsv" type="file" accept=".csv" class="hidden" />
            <span id="csvName" class="text-sm text-gray-600"></span>
          </div>

          <div class="flex items-center gap-3">
            <button
              id="btnStart"
              class="inline-flex items-center gap-2 rounded-lg px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white disabled:opacity-50 disabled:cursor-not-allowed transition"
              disabled
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-4 w-4 opacity-90"
                viewBox="0 0 20 20"
                fill="currentColor"
              >
                <path d="M6 4l10 6-10 6V4z" />
              </svg>
              <span>Start Run</span>
            </button>
            <button
              id="btnStop"
              type="button"
              class="inline-flex items-center gap-2 rounded-lg px-4 py-2 bg-rose-600 hover:bg-rose-700 text-white disabled:opacity-50 disabled:cursor-not-allowed transition hidden"
            >
              <!-- x-circle -->
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-4 w-4 opacity-90"
                viewBox="0 0 20 20"
                fill="currentColor"
              >
                <path
                  fill-rule="evenodd"
                  d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                  clip-rule="evenodd"
                />
              </svg>
              <span>Stop</span>
            </button>
            <div
              id="spinner"
              class="hidden h-5 w-5 border-2 border-indigo-600 border-t-transparent rounded-full animate-spin"
            ></div>
          </div>
        </div>
        <p class="mt-2 text-xs text-gray-500">
          Upload a file to begin a new run. CSV must include
          <code class="px-1 rounded bg-gray-100">entity_name</code>.
        </p>
      </section>

      <!-- === Run Overview (Dedicated Section) === -->
      <section id="run-overview" class="w-full">
        <div class="mb-3 flex items-center justify-between">
          <h2 class="text-lg font-semibold tracking-tight">Run Overview</h2>
          <!-- optional slot for a small hint or timestamp -->
          <span id="overviewHint" class="text-xs text-gray-500"></span>
        </div>

        <!-- Horizontal stats row (always one line; scrolls on small screens) -->
        <div class="w-full overflow-x-auto">
          <div class="flex flex-nowrap gap-4 w-full">
            <div
              class="basis-1/4 min-w-[220px] bg-white border border-gray-200 rounded-xl shadow-sm p-4"
            >
              <div class="text-sm text-gray-500">Queued (from CSV)</div>
              <div id="statQueued" class="text-2xl font-semibold">0</div>
            </div>
            <div
              class="basis-1/4 min-w-[220px] bg-white border border-gray-200 rounded-xl shadow-sm p-4"
            >
              <div class="text-sm text-gray-500">Completed (latest batch)</div>
              <div id="statDone" class="text-2xl font-semibold">0</div>
            </div>
            <div
              class="basis-1/4 min-w-[220px] bg-white border border-gray-200 rounded-xl shadow-sm p-4"
            >
              <div class="text-sm text-gray-500">Errors</div>
              <div id="statErr" class="text-2xl font-semibold">0</div>
            </div>
            <div
              class="basis-1/4 min-w-[220px] bg-white border border-gray-200 rounded-xl shadow-sm p-4"
            >
              <div class="text-sm text-gray-500">Avg Duration</div>
              <div id="statAvg" class="text-2xl font-semibold">—</div>
            </div>
          </div>
        </div>
      </section>

      <!-- Live Log + Progress -->
      <section class="grid lg:grid-cols-3 items-stretch gap-6">
        <!-- Progress Timeline card -->
        <div
          class="bg-white border border-gray-200 rounded-xl shadow-sm p-4 sm:p-5 flex flex-col h-full min-h-[18rem] max-h-[50vh] md:max-h-[55vh] lg:max-h-[60vh]"
        >
          <div class="flex items-center justify-between mb-2">
            <h2 class="text-lg font-semibold">Progress Timeline</h2>
            <span id="uxEntity" class="text-sm text-gray-500"></span>
          </div>

          <!-- scrollable area (matches Live Log height) -->
          <ol
            id="uxTimeline"
            class="flex-1 min-h-0 overflow-auto space-y-3 pl-3 sm:pl-4"
          ></ol>

          <p id="uxHint" class="mt-3 text-xs text-gray-500">
            Quick overview of the filing. For full details, check the Live Log.
          </p>
        </div>

        <!-- Live Log card -->
        <div
          class="lg:col-span-2 bg-white border border-gray-200 rounded-xl shadow-sm p-4 sm:p-5 flex flex-col h-full min-h-[18rem] max-h-[50vh] md:max-h-[55vh] lg:max-h-[60vh]"
        >
          <div class="flex items-center justify-between mb-2">
            <h2 class="text-lg font-semibold">Live Log</h2>
            <button
              id="btnClearLog"
              class="text-sm text-gray-500 hover:text-gray-700"
            >
              Clear
            </button>
          </div>

          <!-- scrollable area (fills card, won't exceed max height) -->
          <pre
            id="liveLog"
            aria-live="polite"
            class="flex-1 min-h-0 overflow-auto text-xs leading-5 bg-gray-900 text-white rounded-lg p-3 whitespace-pre-wrap"
          ></pre>

          <div id="afterRunLinks" class="mt-2 text-sm text-indigo-700"></div>
        </div>
      </section>

      <!-- Queue + Recent Results -->
      <section class="grid lg:grid-cols-[1fr_1.7fr] gap-6">
        <div
          class="bg-white border border-gray-200 rounded-xl shadow-sm p-4 sm:p-5"
        >
          <div class="flex items-center justify-between mb-3">
            <h3 class="font-semibold">Queue Preview</h3>
            <span
              id="queueCount"
              class="inline-flex items-center rounded-full px-2.5 py-0.5 text-xs bg-gray-100 text-gray-700"
              >0 items</span
            >
          </div>
          <div
            class="overflow-auto max-h-[420px] border border-gray-200 rounded-lg"
          >
            <table class="min-w-full text-sm">
              <thead class="sticky-th">
                <tr class="border-b border-gray-200">
                  <th class="text-left px-3 py-2 text-gray-600">#</th>
                  <th class="text-left px-3 py-2 text-gray-600">Entity Name</th>
                  <!-- <th class="text-left px-3 py-2 text-gray-600">
                    Registered Agent
                  </th> -->
                </tr>
              </thead>
              <tbody id="queueBody"></tbody>
            </table>
          </div>
        </div>

        <!-- Recent Results card -->
        <div
          class="bg-white border border-gray-200 rounded-xl shadow-sm p-4 sm:p-5 min-w-0 overflow-hidden"
        >
          <div
            class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between mb-3"
          >
            <div class="min-w-0">
              <div class="flex items-center gap-2 flex-wrap">
                <h3 class="font-semibold" id="recentResultsHeading">
                  Recent Results
                </h3>
                <span
                  id="resCount"
                  aria-live="polite"
                  class="inline-flex items-center rounded-full px-2.5 py-0.5 text-xs bg-gray-100 text-gray-700"
                  >0 rows</span
                >
                <span
                  id="scopeBadge"
                  class="inline-flex items-center rounded-full px-2 py-0.5 text-[11px] font-medium bg-violet-100 text-violet-700 ring-1 ring-inset ring-violet-200"
                  >Combined</span
                >
              </div>
              <p id="recentResultsSub" class="text-xs text-gray-500"></p>
            </div>

            <div class="flex flex-wrap items-center gap-2">
              <div class="flex items-center gap-2">
                <div class="relative">
                  <label for="runSelect" class="sr-only">Select run</label>
                  <svg
                    class="pointer-events-none absolute left-2.5 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    aria-hidden="true"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M10 18a8 8 0 100-16 8 8 0 000 16zm.75-13a.75.75 0 00-1.5 0v5c0 .414.336.75.75.75h4a.75.75 0 000-1.5h-3.25V5z"
                      clip-rule="evenodd"
                    />
                  </svg>
                  <select
                    id="runSelect"
                    class="appearance-none border border-gray-300 rounded-lg bg-white text-sm pl-8 pr-9 py-1.5 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                  >
                    <option value="__combined__">Last 7 days (combined)</option>
                  </select>
                  <svg
                    class="pointer-events-none absolute right-2.5 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    aria-hidden="true"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M5.22 8.22a.75.75 0 011.06 0L10 11.94l3.72-3.72a.75.75 0 111.06 1.06l-4.25 4.25a.75.75 0 01-1.06 0L5.22 9.28a.75.75 0 010-1.06z"
                      clip-rule="evenodd"
                    />
                  </svg>
                  <div
                    id="runSelectSpinner"
                    class="hidden absolute right-2 top-1/2 -translate-y-1/2 h-4 w-4 border-2 border-gray-300 border-t-transparent rounded-full animate-spin"
                    aria-label="Loading runs"
                  ></div>
                </div>

                <button
                  id="refreshRunsBtn"
                  class="inline-flex items-center justify-center rounded-lg border border-gray-200 bg-white h-9 w-9 text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                  title="Reload run list"
                  type="button"
                  aria-label="Reload run list"
                >
                  <svg
                    class="h-5 w-5"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke-width="2"
                    stroke="currentColor"
                    aria-hidden="true"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99"
                    />
                  </svg>
                </button>
              </div>

              <span class="hidden sm:inline w-px h-6 bg-gray-200 mx-1"></span>

              <div class="relative">
                <button
                  id="exportMenuBtn"
                  type="button"
                  aria-haspopup="true"
                  aria-expanded="false"
                  class="inline-flex items-center gap-1.5 rounded-lg border border-gray-200 bg-white px-2.5 py-1.5 text-sm text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <svg
                    class="h-4 w-4"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    aria-hidden="true"
                  >
                    <path
                      d="M10.75 2.75a.75.75 0 00-1.5 0v8.614L6.295 8.235a.75.75 0 10-1.09 1.03l4.25 4.5a.75.75 0 001.09 0l4.25-4.5a.75.75 0 00-1.09-1.03l-2.955 3.129V2.75z"
                    />
                    <path
                      d="M3.5 12.75a.75.75 0 00-1.5 0v2.5A2.75 2.75 0 004.75 18h10.5A2.75 2.75 0 0018 15.25v-2.5a.75.75 0 00-1.5 0v2.5c0 .69-.56 1.25-1.25 1.25H4.75c-.69 0-1.25-.56-1.25-1.25v-2.5z"
                    />
                  </svg>
                  Export
                  <svg
                    class="h-3.5 w-3.5 opacity-60"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    aria-hidden="true"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M5.22 8.22a.75.75 0 011.06 0L10 11.94l3.72-3.72a.75.75 0 111.06 1.06l-4.25 4.25a.75.75 0 01-1.06 0L5.22 9.28a.75.75 0 010-1.06z"
                      clip-rule="evenodd"
                    />
                  </svg>
                </button>

                <div
                  id="exportMenuPanel"
                  class="hidden absolute right-0 mt-1 w-48 rounded-md border border-gray-200 bg-white shadow-lg p-1 z-10"
                  role="menu"
                  aria-labelledby="exportMenuBtn"
                >
                  <a
                    id="runDownloadCsv"
                    class="hidden group flex items-center gap-2 rounded-md px-3 py-2 text-sm text-gray-700 hover:bg-gray-50"
                    href="#"
                    target="_blank"
                    rel="noopener"
                    role="menuitem"
                  >
                    <svg
                      class="h-4 w-4 text-gray-500 group-hover:text-gray-700"
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                      aria-hidden="true"
                    >
                      <path
                        d="M7.75 3a.75.75 0 01.75.75v2.25h3.5V3.75a.75.75 0 011.5 0v2.25h2.25a.75.75 0 010 1.5h-2.25V9.75h2.25a.75.75 0 010 1.5h-2.25v2.25a.75.75 0 01-1.5 0V11.25h-3.5v2.25a.75.75 0 01-1.5 0V11.25H3.75a.75.75 0 010-1.5H6V7.5H3.75a.75.75 0 010-1.5H6V3.75A.75.75 0 016.75 3h1zM8.5 7.5h3.5V9.75H8.5V7.5z"
                      />
                      <path
                        fill-rule="evenodd"
                        d="M3 4.25A2.25 2.25 0 015.25 2h9.5A2.25 2.25 0 0117 4.25v11.5A2.25 2.25 0 0114.75 18h-9.5A2.25 2.25 0 013 15.75V4.25zm1.5 0V15.75a.75.75 0 00.75.75h9.5a.75.75 0 00.75-.75V4.25a.75.75 0 00-.75-.75h-9.5a.75.75 0 00-.75.75z"
                        clip-rule="evenodd"
                      />
                    </svg>
                    Download CSV
                  </a>

                  <a
                    id="runDownloadZip"
                    class="hidden group flex items-center gap-2 rounded-md px-3 py-2 text-sm text-gray-700 hover:bg-gray-50"
                    href="#"
                    target="_blank"
                    rel="noopener"
                    role="menuitem"
                  >
                    <svg
                      class="h-4 w-4 text-gray-500 group-hover:text-gray-700"
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                      aria-hidden="true"
                    >
                      <path
                        fill-rule="evenodd"
                        d="M2 4.75A.75.75 0 012.75 4h14.5a.75.75 0 01.75.75v2.5a.75.75 0 01-.75.75H2.75a.75.75 0 01-.75-.75v-2.5zm15 0v2.5h-14.5v-2.5h14.5zM2.75 10a.75.75 0 00-.75.75v4.5c0 .414.336.75.75.75h14.5a.75.75 0 00.75-.75v-4.5a.75.75 0 00-.75-.75H2.75zm1.5 4.25v-2.75h11.5v2.75H4.25z"
                        clip-rule="evenodd"
                      />
                    </svg>
                    Download docs (.zip)
                  </a>

                  <div
                    id="exportUnavailable"
                    class="flex items-center gap-2 rounded-md px-3 py-2 text-sm text-gray-400"
                    role="menuitem"
                  >
                    <svg
                      class="h-4 w-4"
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                      aria-hidden="true"
                    >
                      <path
                        fill-rule="evenodd"
                        d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z"
                        clip-rule="evenodd"
                      />
                    </svg>
                    Select a specific run to export
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Keep your inner scroll container; now it’ll actually constrain width -->
          <div class="border border-gray-200 rounded-lg">
            <div
              class="w-full max-w-full overflow-x-auto overflow-y-auto max-h-[420px]"
            >
              <table class="min-w-full table-auto text-sm align-middle">
                <colgroup>
                  <col style="min-width: 9rem" />
                  <!-- When -->
                  <col style="min-width: 10rem" />
                  <!-- Entity -->
                  <col style="min-width: 8rem" />
                  <!-- Status -->
                  <col style="min-width: 12rem" />
                  <!-- Filing ID -->
                  <col style="min-width: 12rem" />
                  <!-- Docs -->
                  <col style="min-width: 30rem" />
                  <!-- Notes -->
                </colgroup>
                <thead class="sticky-th">
                  <tr class="border-b border-gray-200">
                    <th class="text-left px-3 py-2 text-gray-600">When</th>
                    <th class="text-left px-3 py-2 text-gray-600">Entity</th>
                    <th class="text-left px-3 py-2 text-gray-600">Status</th>
                    <th class="text-left px-3 py-2 text-gray-600">Filing ID</th>
                    <th class="text-left px-3 py-2 text-gray-600">Docs</th>
                    <th class="text-left px-3 py-2 text-gray-600">Notes</th>
                  </tr>
                </thead>
                <tbody id="resBody" class="divide-y divide-gray-100"></tbody>
              </table>
            </div>
          </div>
        </div>
      </section>

      <footer class="py-6 text-center text-sm text-gray-500">
        Deployed mode — server handles secrets & storage.
      </footer>
    </div>

    <script>
      // --- state ---
      let currentCsvPath = null;
      let sse = null;
      let isRunning = false;
      let queueRows = [];
      let doneCount = 0;
      let errCount = 0;
      let queuePollTimer = null;
      let _qpTimer = null;
      let RUN_GUARDS_INSTALLED = false;
      let RUN_GUARDS_ENABLED = false;
      let DEFAULTS = { registered_agent_name: "" };
      let _pressTimer;
      let autoScrollTimeline = true; // follow new events unless user scrolls up
      // Friendly UX state (per current entity)
      let ux = {
        entity: "",
        stages: new Map(), // stage -> {items: [{msg, level, at}], lastLevel}
      };

      // --- els ---
      const csvInput = document.getElementById("fileCsv");
      const csvName = document.getElementById("csvName");
      const btnStart = document.getElementById("btnStart");
      const btnStop = document.getElementById("btnStop");
      const spinner = document.getElementById("spinner");
      const runStatus = document.getElementById("runStatus");
      const liveLog = document.getElementById("liveLog");
      const btnClear = document.getElementById("btnClearLog");
      const queueBody = document.getElementById("queueBody");
      const queueCount = document.getElementById("queueCount");
      const statQueued = document.getElementById("statQueued");
      const resBody = document.getElementById("resBody");
      const resCount = document.getElementById("resCount");
      const statDone = document.getElementById("statDone");
      const statErr = document.getElementById("statErr");
      const statAvg = document.getElementById("statAvg");
      const afterRunLinks = document.getElementById("afterRunLinks");
      const uxTimeline = document.getElementById("uxTimeline");
      const uxEntity = document.getElementById("uxEntity");
      const RECENT_DAYS = 7;
      const recentResultsSub = document.getElementById("recentResultsSub");
      const runSelectSpinner = document.getElementById("runSelectSpinner");
      const refreshRunsBtn = document.getElementById("refreshRunsBtn");
      const scopeBadge = document.getElementById("scopeBadge");
      const exportMenuBtn = document.getElementById("exportMenuBtn");
      const exportMenuPanel = document.getElementById("exportMenuPanel");
      const exportUnavailable = document.getElementById("exportUnavailable");
      const STATUS = {
        start: {
          label: "In progress",
          dot: "bg-blue-500",
          ring: "ring-blue-200",
          pill: "bg-blue-100 text-blue-700",
        },
        success: {
          label: "Completed",
          dot: "bg-emerald-500",
          ring: "ring-emerald-200",
          pill: "bg-emerald-100 text-emerald-700",
        },
        error: {
          label: "Needs attention",
          dot: "bg-rose-500",
          ring: "ring-rose-200",
          pill: "bg-rose-100 text-rose-700",
        },
        info: {
          label: "Info",
          dot: "bg-slate-400",
          ring: "ring-slate-200",
          pill: "bg-slate-100 text-slate-700",
        },
        skipped: {
          label: "Skipped",
          dot: "bg-amber-500",
          ring: "ring-amber-200",
          pill: "bg-amber-100 text-amber-700",
        },
      };

      function setRunning(v) {
        isRunning = v;
        btnStart.disabled = !currentCsvPath || v;
        btnStop.classList.toggle("hidden", !v);
        btnStop.disabled = false;
        btnStop.querySelector("span").textContent = "Stop";
        spinner.classList.toggle("hidden", !v);
        runStatus.textContent = v ? "Running" : "Idle";
        runStatus.className = v
          ? "inline-flex items-center rounded-full px-3 py-1 text-xs font-medium bg-blue-100 text-blue-700"
          : "inline-flex items-center rounded-full px-3 py-1 text-xs font-medium bg-gray-200 text-gray-700";
        toggleRunGuards(v);
      }

      function appendLog(line) {
        liveLog.textContent += line + "\n";
        liveLog.scrollTop = liveLog.scrollHeight;
      }

      function badge(status) {
        const s = (status || "").toUpperCase();
        if (s === "SUCCESS")
          return '<span class="inline-flex items-center rounded-full px-2 py-0.5 text-xs bg-green-100 text-green-700">SUCCESS</span>';
        if (s === "ERROR")
          return '<span class="inline-flex items-center rounded-full px-2 py-0.5 text-xs bg-red-100 text-red-700">ERROR</span>';
        if (s === "SKIPPED")
          return '<span class="inline-flex items-center rounded-full px-2 py-0.5 text-xs bg-amber-100 text-amber-700">SKIPPED</span>';
        return `<span class="inline-flex items-center rounded-full px-2 py-0.5 text-xs bg-gray-100 text-gray-700">${
          status || "—"
        }</span>`;
      }

      // Replace your toWeb() with this:
      function toWeb(p) {
        if (!p) return "";
        p = String(p).trim().replace(/\\/g, "/"); // normalize windows paths
        // absolute path containing /output/
        const ix = p.indexOf("/output/");
        if (ix >= 0) return p.slice(ix);

        // relative "output/..."
        if (p.startsWith("output/")) return "/" + p;

        // bare filename -> assume it's inside /output
        if (!p.includes("/") && p) return "/output/" + p;

        // already a web path or something else
        return p.startsWith("/output/") ? p : "";
      }

      function renderQueue(rows) {
        queueBody.innerHTML = rows
          .map((r, i) => {
            const ent = escapeHtml(
              cleanEntity(r.entity_name || r.entity || "—")
            );
            const ra = escapeHtml(
              cleanAgent(
                r.registered_agent_name || DEFAULTS.registered_agent_name || "—"
              )
            );
            return `
          <tr class="border-b border-gray-100" data-i="${i}">
            <td class="px-3 py-2 text-gray-500">${i + 1}</td>
            <td class="px-3 py-2 font-medium break-words">${ent}</td>
          </tr>
        `;
          })
          .join("");
        queueCount.textContent = `${rows.length} item${
          rows.length === 1 ? "" : "s"
        }`;
        statQueued.textContent = rows.length;
      }

      function wireEventStream(es) {
        es.onmessage = (evt) => {
          const line = evt.data || "";
          appendLog(line);

          // Structured events
          if (line.startsWith("[[EVT]] ")) {
            try {
              const ev = JSON.parse(line.slice(8));

              if (ev.type === "start") {
                highlightQueueRow(ev.idx - 1);
                resetUX(ev.entity || "");
              } else if (ev.type === "finish") {
                // current item finished (success or error)
                removeFromQueue(ev.idx - 1, ev.entity);
                addRecentResult(ev);
              } else if (ev.type === "stopping") {
                // soft-stop requested
                runStatus.textContent = "Stopping…";
                runStatus.className =
                  "inline-flex items-center rounded-full px-3 py-1 text-xs font-medium bg-amber-100 text-amber-700";
                // optional: reflect on the Stop button if present
                const btnStop = document.getElementById("btnStop");
                if (btnStop) {
                  btnStop.disabled = true;
                  const lbl = btnStop.querySelector("span");
                  if (lbl) lbl.textContent = "Stopping…";
                }
              } else if (ev.type === "aborted") {
                // aborted mid-run (hard stop or soft stop after current)
                setRunning(false);
                stopQueuePolling?.();
                runStatus.textContent = "Stopped";
                runStatus.className =
                  "inline-flex items-center rounded-full px-3 py-1 text-xs font-medium bg-rose-100 text-rose-700";
                try {
                  es.close();
                } catch {}
              } else if (ev.type === "batch_done") {
                // normal completion or stopped-after-partial
                setRunning(false);
                clearQueueUI();
                stopQueuePolling?.();

                // small grace period so the results file is flushed
                setTimeout(async () => {
                  await populateRunDropdown(RECENT_DAYS, true);
                }, 300);

                if (ev.results_path) {
                  const name = (ev.results_path.split("/").pop() || "").trim();
                  afterRunLinks.innerHTML = `<a class="text-indigo-700 underline" href="/download/${name}">Download latest results</a>`;
                }

                if (ev.aborted) {
                  runStatus.textContent = "Stopped";
                  runStatus.className =
                    "inline-flex items-center rounded-full px-3 py-1 text-xs font-medium bg-rose-100 text-rose-700";
                }
              }
            } catch {}
          }

          // Run metadata
          if (line.startsWith("[[RUN]] ")) {
            const meta = JSON.parse(line.slice(7));
            window.__currentRunId = meta.id;

            // 🚀 New: start live queue polling for this run
            if (currentCsvPath) {
              startQueuePolling(currentCsvPath, meta.id);
            }
          }

          // Fallback marker when main writes the path directly
          if (line.startsWith(">>> Results written to: ")) {
            setRunning(false);
            clearQueueUI();
            stopQueuePolling?.();
            const p = line.replace(">>> Results written to: ", "").trim();
            const name = p.split("/").pop();
            afterRunLinks.innerHTML = `<a class="text-indigo-700 underline" href="/download/${name}">Download latest results</a>`;
            loadRecentResults();
          }

          // UX timeline entries
          if (line.startsWith("[[UX]] ")) {
            try {
              const u = JSON.parse(line.slice(7));
              pushUX(
                u.stage || "Step",
                u.message || "",
                u.level || "info",
                u.entity || ""
              );
            } catch {}
          }
        };

        es.onerror = () => {
          appendLog("[stream closed]");
          // If the server closed because the run ended or stopped, setRunning(false) is OK.
          setRunning(false);
          try {
            es.close();
          } catch {}
        };
      }

      function highlightQueueRow(idx) {
        const tr = document.querySelector(`#queueBody tr[data-i="${idx}"]`);
        if (tr) tr.classList.add("bg-amber-50");
      }

      function removeFromQueue(idx, entityName) {
        if (idx >= 0 && idx < queueRows.length) {
          queueRows.splice(idx, 1);
        } else {
          const i = queueRows.findIndex(
            (r) =>
              cleanEntity(r.entity_name || "") === cleanEntity(entityName || "")
          );
          if (i >= 0) queueRows.splice(i, 1);
        }
        renderQueue(queueRows);
      }

      function addRecentResult(ev) {
        if (ev.status === "SUCCESS") doneCount++;
        if (ev.status === "ERROR") errCount++;
        statDone.textContent = doneCount;
        statErr.textContent = errCount;

        const rec = ev.receipt_file
          ? docPill(ev.receipt_file, "Receipt", "slate")
          : "";
        const reg = ev.registration_file
          ? docPill(ev.registration_file, "Registration", "indigo")
          : "";
        const cgs = ev.cgs_file ? docPill(ev.cgs_file, "CGS", "violet") : "";
        const gsc = ev.gsc_file ? docPill(ev.gsc_file, "GSC", "cyan") : "";
        const docs =
          [rec, reg, cgs, gsc].filter(Boolean).join(pillSep()) || "—";

        const now = new Date().toISOString().slice(0, 16).replace("T", " ");
        const note = cleanNote(ev.notes);
        const entityClean = cleanEntity(ev.entity);
        const rowHtml = `
        <tr class="hover:bg-gray-50">
        <td class="px-3 py-2 text-gray-500 tabular-nums">${now}</td>
        <td class="px-3 py-2 text-left font-medium whitespace-normal break-words [overflow-wrap:anywhere]">${escapeHtml(
          entityClean || "—"
        )}</td>
        <td class="px-3 py-2">${badge(ev.status)}</td>
        <td class="px-3 py-2">${escapeHtml(ev.filing_id || "—")}</td>
        <td class="px-3 py-2"><div class="flex flex-wrap gap-1 items-center">${
          docs || "—"
        }</div></td>
        <td class="px-3 py-2 text-gray-700 text-left whitespace-normal break-words">${
          note ? escapeHtml(note) : "—"
        }</td>
        </tr>`;
        resBody.insertAdjacentHTML("afterbegin", rowHtml);

        const rows = resBody.querySelectorAll("tr").length;
        resCount.textContent = `${rows} row${rows === 1 ? "" : "s"}`;
      }

      function scrollTimeline(force = false) {
        if (!uxTimeline) return;
        if (force || autoScrollTimeline) {
          uxTimeline.scrollTo({
            top: uxTimeline.scrollHeight,
            behavior: "smooth",
          });
        }
      }

      function setupTimelineAutoscroll() {
        // make the timeline card a positioning context for our button
        const card = uxTimeline.parentElement; // the white card wrapping the <ol>
        card.classList.add("relative");

        // floating "Jump to live" button
        const jumpBtn = document.createElement("button");
        jumpBtn.id = "btnJumpLive";
        jumpBtn.className =
          "hidden absolute bottom-3 right-3 text-xs px-2.5 py-1.5 rounded-lg bg-amber-100 text-amber-700 shadow ring-1 ring-amber-200";
        jumpBtn.textContent = "Jump to live";
        jumpBtn.addEventListener("click", () => {
          autoScrollTimeline = true;
          scrollTimeline(true);
        });
        card.appendChild(jumpBtn);

        // if user scrolls up: pause follow; when near bottom: resume follow
        uxTimeline.addEventListener("scroll", () => {
          const nearBottom =
            uxTimeline.scrollTop + uxTimeline.clientHeight >=
            uxTimeline.scrollHeight - 24; // px threshold
          autoScrollTimeline = nearBottom;
          jumpBtn.classList.toggle("hidden", autoScrollTimeline);
        });
      }

      // factor out your row rendering so both loaders can use it
      function renderResultsRows(rows) {
        resBody.innerHTML = rows
          .map((r) => {
            const recP = toWeb(r.receipt_file || "");
            const regP = toWeb(r.registration_file || "");
            const cgsP = toWeb(r.cgs_file || "");
            const gscP = toWeb(r.gsc_file || "");

            const rec = recP ? docPill(recP, "Receipt", "slate") : "";
            const reg = regP ? docPill(regP, "Registration", "indigo") : "";
            const cgs = cgsP ? docPill(cgsP, "CGS", "violet") : "";
            const gsc = gscP ? docPill(gscP, "GSC", "cyan") : "";
            const docs =
              [rec, reg, cgs, gsc].filter(Boolean).join(pillSep()) || "—";

            const note = cleanNote(r.notes);
            const ent = cleanEntity(r.entity_name || r.entity || "—");

            return `
              <tr class="hover:bg-gray-50">
                <td class="px-3 py-2 text-gray-500 tabular-nums">${escapeHtml(
                  r.started_at || "—"
                )}</td>
                <td class="px-3 py-2 text-left font-medium whitespace-normal break-words [overflow-wrap:anywhere]">${escapeHtml(
                  ent
                )}</td>
                <td class="px-3 py-2">${badge(r.status)}</td>
                <td class="px-3 py-2">${escapeHtml(r.filing_id || "—")}</td>
                <td class="px-3 py-2"><div class="flex flex-wrap gap-1 items-center">${docs}</div></td>
                <td class="px-3 py-2 text-gray-700 text-left whitespace-normal break-words">
                  ${note ? escapeHtml(note) : "—"}
                </td>
              </tr>`;
          })
          .join("");

        const n = rows.length;
        resCount.textContent = `${n} row${n === 1 ? "" : "s"}`;
      }

      function refreshExportMenuState() {
        const sel = document.getElementById("runSelect");
        const dlCsv = document.getElementById("runDownloadCsv");
        const dlZip = document.getElementById("runDownloadZip");
        const exportBtn = document.getElementById("exportMenuBtn");
        const exportPanel = document.getElementById("exportMenuPanel");
        const unavailable = document.getElementById("exportUnavailable");

        const singleRun = sel && sel.value !== "__combined__";
        const hasCsv = dlCsv && !dlCsv.classList.contains("hidden");
        const hasZip = dlZip && !dlZip.classList.contains("hidden");
        const anythingToExport = singleRun && (hasCsv || hasZip);

        if (unavailable) {
          // Show hint only when there’s nothing to export
          unavailable.classList.toggle("hidden", anythingToExport);
        }

        if (exportBtn) {
          // Disable the button when export isn’t available
          if (!anythingToExport) {
            exportBtn.setAttribute("disabled", "disabled");
            exportBtn.classList.add("opacity-50", "cursor-not-allowed");
            if (exportPanel) {
              exportPanel.classList.add("hidden");
              exportBtn.setAttribute("aria-expanded", "false");
            }
          } else {
            exportBtn.removeAttribute("disabled");
            exportBtn.classList.remove("opacity-50", "cursor-not-allowed");
          }
        }
      }

      async function populateRunDropdown(
        days = RECENT_DAYS,
        preserveSelection = true
      ) {
        const sel = document.getElementById("runSelect");
        const dlCsv = document.getElementById("runDownloadCsv");
        const dlZip = document.getElementById("runDownloadZip");
        const sub = document.getElementById("recentResultsSub");
        const spin = document.getElementById("runSelectSpinner");

        const previous = sel.value;

        // loading UI
        sel.disabled = true;
        sel.classList.add("opacity-60", "cursor-wait");
        spin?.classList.remove("hidden");

        try {
          // Reset with "combined" first; we’ll remove if unsupported.
          sel.innerHTML = `<option value="__combined__">Last ${days} days (combined)</option>`;

          let runs = [];
          try {
            runs = await fetch(
              `/result-files?days=${encodeURIComponent(days)}`
            ).then((r) => r.json());
          } catch (e) {
            console.warn("result-files failed", e);
          }
          if (!Array.isArray(runs)) runs = [];

          // Probe combined endpoint
          let hasCombined = true;
          try {
            const probe = await fetch(
              `/recent-results?days=${encodeURIComponent(days)}`
            );
            if (!probe.ok) {
              sel.querySelector('option[value="__combined__"]')?.remove();
              hasCombined = false;
            }
          } catch {
            sel.querySelector('option[value="__combined__"]')?.remove();
            hasCombined = false;
          }

          // Empty state if no runs and no combined
          if (runs.length === 0 && !hasCombined) {
            resBody.innerHTML = `<tr><td colspan="6" class="px-3 py-6 text-sm text-slate-500">No runs in the last ${days} days.</td></tr>`;
            resCount.textContent = "0 rows";
            dlCsv.classList.add("hidden");
            dlCsv.removeAttribute("href");
            dlZip.classList.add("hidden");
            dlZip.removeAttribute("href");
            // sub && (sub.textContent = `Last ${days} days`);
            return;
          }

          // PATCH: build run <option>s with a concrete /output/<filename>.csv
          for (const r of runs) {
            const opt = document.createElement("option");
            if (r.name && !r.name.endsWith("/")) {
              opt.value = `/output/${encodeURIComponent(r.name)}`; // concrete, per-run CSV
              opt.dataset.name = r.name;
            } else {
              opt.value = r.url; // fallback
            }
            if (r.zip) opt.dataset.zip = r.zip;
            opt.textContent = r.label || r.name || r.url;
            sel.appendChild(opt);
          }

          // Prefer to keep user’s selection; otherwise default to Combined if available
          if (
            preserveSelection &&
            [...sel.options].some((o) => o.value === previous)
          ) {
            sel.value = previous;
          } else if (hasCombined) {
            sel.value = "__combined__";
          } else if (runs.length) {
            sel.value = runs[0].url; // fallback to most recent single run
          }

          sel.onchange = async () => {
            await loadSelectedRun();
            // if (sel.value === "__combined__") {
            //   // sub && (sub.textContent = `Last ${days} days`);
            // } else {
            //   sub &&
            //     (sub.textContent =
            //       sel.options[sel.selectedIndex]?.textContent || "");
            // }
          };

          await loadSelectedRun();
          // if (sel.value === "__combined__") {
          //   // sub && (sub.textContent = `Last ${days} days`);
          // } else {
          //   sub &&
          //     (sub.textContent =
          //       sel.options[sel.selectedIndex]?.textContent || "");
          // }
        } finally {
          sel.disabled = false;
          sel.classList.remove("opacity-60", "cursor-wait");
          spin?.classList.add("hidden");
        }
      }

      async function loadSelectedRun() {
        const sel = document.getElementById("runSelect");
        const value = sel.value;
        const dlCsv = document.getElementById("runDownloadCsv");
        const dlZip = document.getElementById("runDownloadZip");

        // Reset links every time
        dlCsv.classList.add("hidden");
        dlCsv.removeAttribute("href");
        dlZip.classList.add("hidden");
        dlZip.removeAttribute("href");

        if (value === "__combined__") {
          // recentResultsSub.textContent = `Last ${RECENT_DAYS} days`;
          await loadCombinedClient(RECENT_DAYS);
          scopeBadge.textContent = "Combined";
          scopeBadge.className =
            "inline-flex items-center rounded-full px-2 py-0.5 text-[11px] font-medium bg-violet-100 text-violet-700 ring-1 ring-inset ring-violet-200";
          refreshExportMenuState?.();
          return;
        }

        // Single run
        try {
          clearRecentResultsUI();

          const opt = sel.options[sel.selectedIndex];
          const { text, usedUrl } = await fetchCsvTextWithFallbacks(opt);

          const parsed = Papa.parse(text, {
            header: true,
            skipEmptyLines: true,
          });
          const all = Array.isArray(parsed.data) ? parsed.data : [];

          // 🔎 If the server sent a combined CSV, trim to this run’s rows.
          const rows = filterRowsToRun(all, opt, usedUrl);
          if (rows.length < all.length) {
            console.warn(
              `Filtered ${all.length - rows.length} aggregated rows`
            );
          }

          renderResultsRows(rows);
          updateStatsFromRows(rows);

          // Downloads (prefer stable /download/<name> if we have one)
          const name = opt?.dataset?.name || fileBaseName(usedUrl);
          if (name) {
            dlCsv.href = `/download/${encodeURIComponent(name)}`;
            dlCsv.classList.remove("hidden");
          }
          const zipUrl = opt?.dataset?.zip;
          if (zipUrl) {
            dlZip.href = zipUrl;
            dlZip.classList.remove("hidden");
          }

          scopeBadge.textContent = "Single run";
          scopeBadge.className =
            "inline-flex items-center rounded-full px-2 py-0.5 text-[11px] font-medium bg-slate-100 text-slate-700 ring-1 ring-inset ring-slate-200";
          // recentResultsSub.textContent =
          //   sel.options[sel.selectedIndex]?.textContent || "";
          refreshExportMenuState?.();
        } catch (e) {
          console.warn("Failed to load selected run with fallbacks", e);
          // Show a friendly hint, then fall back to combined as a last resort
          resBody.innerHTML = `<tr><td colspan="6" class="px-3 py-6 text-sm text-amber-700 bg-amber-50 rounded-md">
            Couldn’t load that run’s CSV. Showing combined results for the last ${RECENT_DAYS} days.
          </td></tr>`;
          await loadCombinedClient(RECENT_DAYS);
          scopeBadge.textContent = "Combined";
          scopeBadge.className =
            "inline-flex items-center rounded-full px-2 py-0.5 text-[11px] font-medium bg-violet-100 text-violet-700 ring-1 ring-inset ring-violet-200";
          refreshExportMenuState?.();
        }
      }

      async function loadRecentResults(days = RECENT_DAYS) {
        try {
          // Preferred: server aggregates all CSVs from the last N days
          const res = await fetch(
            `/recent-results?days=${encodeURIComponent(days)}`
          );
          if (!res.ok) throw new Error("recent-results not available");
          const payload = await res.json();
          const rows = Array.isArray(payload) ? payload : payload.rows || [];

          // If your backend isn’t ready or returns empty, show the latest CSV instead
          if (!rows.length) {
            await loadLatestResults();
            return;
          }

          // ---- render (same structure you use in loadLatestResults) ----
          resBody.innerHTML = rows
            .map((r) => {
              const recP = toWeb(r.receipt_file || "");
              const regP = toWeb(r.registration_file || "");
              const cgsP = toWeb(r.cgs_file || "");
              const gscP = toWeb(r.gsc_file || "");

              const rec = recP ? docPill(recP, "Receipt", "slate") : "";
              const reg = regP ? docPill(regP, "Registration", "indigo") : "";
              const cgs = cgsP ? docPill(cgsP, "CGS", "violet") : "";
              const gsc = gscP ? docPill(gscP, "GSC", "cyan") : "";
              const docs =
                [rec, reg, cgs, gsc].filter(Boolean).join(pillSep()) || "—";

              const note = cleanNote(r.notes);
              const ent = cleanEntity(r.entity_name || r.entity || "—");

              return `
                <tr class="hover:bg-gray-50">
                  <td class="px-3 py-2 text-gray-500 tabular-nums">${escapeHtml(
                    r.started_at || "—"
                  )}</td>
                  <td class="px-3 py-2 text-left font-medium whitespace-normal break-words [overflow-wrap:anywhere]">${escapeHtml(
                    ent
                  )}</td>
                  <td class="px-3 py-2">${badge(r.status)}</td>
                  <td class="px-3 py-2">${escapeHtml(r.filing_id || "—")}</td>
                  <td class="px-3 py-2"><div class="flex flex-wrap gap-1 items-center">${docs}</div></td>
                  <td class="px-3 py-2 text-gray-700 text-left whitespace-normal break-words">
                    ${note ? escapeHtml(note) : "—"}
                  </td>
                </tr>`;
            })
            .join("");

          resCount.textContent = `${rows.length} row${
            rows.length === 1 ? "" : "s"
          }`;

          const done = rows.filter(
            (r) => (r.status || "").toUpperCase() === "SUCCESS"
          ).length;
          const errs = rows.filter(
            (r) => (r.status || "").toUpperCase() === "ERROR"
          ).length;
          statDone.textContent = done;
          statErr.textContent = errs;

          const durations = rows
            .map((r) => parseFloat(r.elapsed_s || "0"))
            .filter((x) => !isNaN(x) && x > 0);
          if (durations.length) {
            const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
            const mm = String(Math.floor(avg / 60)).padStart(2, "0");
            const ss = String(Math.floor(avg % 60)).padStart(2, "0");
            statAvg.textContent = `${mm}:${ss}`;
          } else {
            statAvg.textContent = "—";
          }
        } catch {
          // Fallback to your existing single-file view if the server
          // doesn’t have /recent-results yet.
          await loadLatestResults();
        }
      }

      async function startQueuePolling(csvPath, runId) {
        stopQueuePolling();

        const tick = async () => {
          try {
            const qp = await fetch(
              `/queue-preview?csv_path=${encodeURIComponent(
                csvPath
              )}&run_id=${encodeURIComponent(runId)}`
            ).then((r) => r.json());

            console.log(qp);

            // If the server also includes the default in this payload, capture it
            if (
              !DEFAULTS.registered_agent_name &&
              qp.default_registered_agent_name
            ) {
              DEFAULTS.registered_agent_name = cleanAgent(
                qp.default_registered_agent_name
              );
            }

            // Apply fallback RA per row for display
            queueRows = (qp.preview || []).map((r) => ({
              ...r,
              registered_agent_name:
                r.registered_agent_name || DEFAULTS.registered_agent_name,
            }));

            renderQueue(queueRows);
            statQueued.textContent = qp.remaining ?? queueRows.length;
            if (qp.current_idx) highlightQueueRow(0);
          } catch {}
          _qpTimer = setTimeout(tick, 3000);
        };
        tick();
      }

      function stopQueuePolling() {
        if (_qpTimer) {
          clearTimeout(_qpTimer);
          _qpTimer = null;
        }
      }

      function installRunGuardsOnce() {
        if (RUN_GUARDS_INSTALLED) return;
        RUN_GUARDS_INSTALLED = true;

        // Warn on close/reload
        window.addEventListener("beforeunload", (e) => {
          if (!RUN_GUARDS_ENABLED) return;
          // Required for Chrome/Safari to show native prompt
          e.preventDefault();
          e.returnValue = "";
        });

        // Block F5 / Cmd/Ctrl+R while running
        document.addEventListener(
          "keydown",
          (e) => {
            if (!RUN_GUARDS_ENABLED) return;
            const isReloadCombo = e.key === "r" && (e.metaKey || e.ctrlKey);
            if (e.key === "F5" || (e.key === "r" && (e.metaKey || e.ctrlKey))) {
              e.preventDefault();
              e.stopPropagation();
            }
            if (
              e.key === "Escape" &&
              exportMenuPanel &&
              !exportMenuPanel.classList.contains("hidden")
            ) {
              exportMenuPanel.classList.add("hidden");
              exportMenuBtn.setAttribute("aria-expanded", "false");
            }
          },
          { capture: true }
        );

        // Trap Back/Forward buttons
        // We push a dummy state and immediately push another whenever popstate fires.
        function pushStateGuard() {
          try {
            history.pushState({ guard: true }, "", location.href);
          } catch {}
        }
        pushStateGuard();
        window.addEventListener("popstate", (e) => {
          if (!RUN_GUARDS_ENABLED) return; // allow normal nav when idle
          pushStateGuard();
          // Optional feedback:
          // alert("Run in progress — navigation is disabled until it finishes.");
        });

        // Soft-block link clicks that would navigate away
        document.addEventListener(
          "click",
          (e) => {
            if (!RUN_GUARDS_ENABLED) return;
            const a = e.target.closest && e.target.closest("a[href]");
            if (!a) return;
            const href = a.getAttribute("href") || "";
            if (!href) return;
            // allow same-page anchors
            if (href.startsWith("#")) return;
            if (
              !exportMenuPanel ||
              exportMenuPanel.classList.contains("hidden")
            )
              return;
            if (
              !exportMenuPanel.contains(e.target) &&
              !exportMenuBtn.contains(e.target)
            ) {
              exportMenuPanel.classList.add("hidden");
              exportMenuBtn.setAttribute("aria-expanded", "false");
            }
            // block external / full nav while running
            e.preventDefault();
            e.stopPropagation();
          },
          { capture: true }
        );
      }

      function updateStatsFromRows(rows) {
        const done = rows.filter(
          (r) => (r.status || "").toUpperCase() === "SUCCESS"
        ).length;
        const errs = rows.filter(
          (r) => (r.status || "").toUpperCase() === "ERROR"
        ).length;
        statDone.textContent = done;
        statErr.textContent = errs;

        const durations = rows
          .map((r) => parseFloat(r.elapsed_s || "0"))
          .filter((x) => !isNaN(x) && x > 0);
        if (durations.length) {
          const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
          const mm = String(Math.floor(avg / 60)).padStart(2, "0");
          const ss = String(Math.floor(avg % 60)).padStart(2, "0");
          statAvg.textContent = `${mm}:${ss}`;
        } else {
          statAvg.textContent = "—";
        }
      }

      function toggleRunGuards(enable) {
        RUN_GUARDS_ENABLED = !!enable;
        const banner = document.getElementById("runGuardBanner");
        banner.classList.toggle("hidden", !enable);
        if (enable) installRunGuardsOnce();
      }

      function clearQueueUI() {
        queueRows = [];
        renderQueue(queueRows);
        document.getElementById("statQueued").textContent = "0";
      }

      // Render friendly timeline
      function renderUX() {
        uxEntity.textContent = ux.entity
          ? `For: ${cleanEntity(ux.entity)}`
          : "";

        const rows = [];
        const entries = Array.from(ux.stages.entries());

        for (let i = 0; i < entries.length; i++) {
          const [stage, data] = entries[i];
          const level = data.lastLevel || "info";
          const cfg = STATUS[level] || STATUS.info;

          const itemsHtml = (data.items || [])
            .map(
              (it) => `
                <div class="text-xs text-slate-600">
                <span class="tabular-nums text-slate-400 mr-1">${fmtTime(
                  it.at
                )}</span>
                ${escapeHtml(it.msg)}
                </div>
            `
            )
            .join("");

          const isCurrent = level === "start";
          const dotPulse = isCurrent ? "animate-pulse" : "";
          const stageTint = isCurrent ? "text-slate-900" : "text-slate-800";

          rows.push(`
            <li class="relative pl-7 py-3">
                <!-- dot -->
                <span class="absolute left-1 top-4 h-3 w-3 rounded-full ${
                  cfg.dot
                } ring-2 ${cfg.ring} ${dotPulse}"></span>
                <!-- connector line (to next step) -->
                ${
                  i < entries.length - 1
                    ? '<span class="absolute left-2 top-7 bottom-[-6px] w-px bg-slate-200"></span>'
                    : ""
                }

                <div class="flex items-center gap-2">
                ${statusPill(level)}
                <div class="font-medium ${stageTint}">${escapeHtml(stage)}</div>
                </div>

                <div class="mt-1">
                ${
                  itemsHtml ||
                  '<div class="text-xs text-slate-400 italic">Waiting…</div>'
                }
                </div>
            </li>
            `);
        }

        uxTimeline.innerHTML =
          rows.join("") ||
          `<li class="text-sm text-slate-500">No activity yet.</li>`;

        scrollTimeline(); // keep following while user hasn't scrolled up
      }

      function resetUX(entityName = "") {
        ux = { entity: entityName || "", stages: new Map() };
        renderUX();

        autoScrollTimeline = true;
        scrollTimeline(true);
      }

      function pushUX(stage, message, level, entityName) {
        if (entityName && (!ux.entity || ux.entity !== entityName)) {
          // Rollover to a new entity
          resetUX(entityName);
        }
        if (!ux.stages.has(stage))
          ux.stages.set(stage, { items: [], lastLevel: "info" });
        const s = ux.stages.get(stage);
        s.items.push({ msg: message, level, at: Date.now() });
        s.lastLevel = level;
        ux.stages.set(stage, s);
        renderUX();
      }

      function statusPill(level) {
        const cfg = STATUS[level] || STATUS.info;
        return `<span class="inline-flex items-center rounded-full px-2 py-0.5 text-[11px] font-medium ${cfg.pill}">
            ${cfg.label}
        </span>`;
      }

      function fmtTime(ms) {
        const d = new Date(ms || Date.now());
        return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }

      function escapeHtml(s) {
        return String(s || "").replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }

      // --- Pretty "pill" links for docs ---
      function iconDoc() {
        // small inline SVG doc icon (Tailwind inherits current text color)
        return `<svg aria-hidden="true" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                <path d="M4 3a2 2 0 0 1 2-2h5.586a2 2 0 0 1 1.414.586l3.414 3.414A2 2 0 0 1 17 6.414V17a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V3z"/>
            </svg>`;
      }

      // color presets: indigo (default), violet (CGS), cyan (GSC)
      function pillClasses(variant = "indigo") {
        const m = {
          indigo: [
            "bg-indigo-50",
            "text-indigo-700",
            "ring-indigo-200",
            "hover:bg-indigo-100",
          ],
          violet: [
            "bg-violet-50",
            "text-violet-700",
            "ring-violet-200",
            "hover:bg-violet-100",
          ],
          cyan: [
            "bg-cyan-50",
            "text-cyan-700",
            "ring-cyan-200",
            "hover:bg-cyan-100",
          ],
          slate: [
            "bg-slate-50",
            "text-slate-700",
            "ring-slate-200",
            "hover:bg-slate-100",
          ],
        }[variant] || [
          "bg-indigo-50",
          "text-indigo-700",
          "ring-indigo-200",
          "hover:bg-indigo-100",
        ];
        return `inline-flex items-center gap-1.5 rounded-full px-2.5 py-1 text-xs font-medium ring-1 ring-inset ${m.join(
          " "
        )}`;
      }

      function docPill(path, label, variant = "indigo") {
        const href = toWeb(path || "");
        if (!href) return "";
        const title = `${label} — opens in new tab`;
        return `<a class="${pillClasses(
          variant
        )}" href="${href}" target="_blank" rel="noopener noreferrer" title="${title}">
            ${iconDoc()} <span>${label}</span>
        </a>`;
      }

      // small separator between pills
      function pillSep() {
        return `<span class="inline-block w-1.5"></span>`;
      }

      function cleanNote(raw) {
        if (raw == null) return "";
        let s = String(raw);

        // strip surrounding quotes if the string was quoted
        s = s.replace(/^\s*["'](.*)["']\s*$/s, "$1");

        // normalize & trim
        s = s.replace(/\u00A0/g, " "); // nbsp -> space
        s = s
          .split(/\r?\n/)
          .map((l) => l.trim())
          .join(" ");
        s = s.replace(/\s{2,}/g, " ").trim();
        return s;
      }

      function cleanEntity(raw) {
        if (raw == null) return "";
        let s = String(raw);

        // strip surrounding quotes if present
        s = s.replace(/^\s*["'](.*)["']\s*$/s, "$1");

        // normalize spaces, trim each line, collapse runs
        s = s.replace(/\u00A0/g, " "); // nbsp -> space
        s = s
          .split(/\r?\n/)
          .map((l) => l.trim())
          .join(" ");
        s = s.replace(/\s{2,}/g, " ").trim();

        return s;
      }

      function cleanAgent(raw) {
        if (raw == null) return "";
        let s = String(raw);
        s = s.replace(/^\s*["'](.*)["']\s*$/s, "$1"); // strip wrapping quotes
        s = s.replace(/\u00A0/g, " "); // nbsp -> space
        s = s
          .split(/\r?\n/)
          .map((l) => l.trim())
          .join(" ");
        s = s.replace(/\s{2,}/g, " ").trim();
        return s;
      }

      function clearTimeline() {
        // wipe UX state + UI immediately
        ux = { entity: "", stages: new Map() };
        uxTimeline.innerHTML = ""; // no placeholder, truly empty
        uxEntity.textContent = ""; // clear "For: …"
        autoScrollTimeline = true; // resume follow when new events arrive
      }

      function clearRecentResultsUI() {
        resBody.innerHTML = "";
        resCount.textContent = "0 rows";
        statDone.textContent = "0";
        statErr.textContent = "0";
        statAvg.textContent = "—";
      }

      function fileBaseName(urlOrName) {
        try {
          const u = new URL(urlOrName, location.origin);
          return decodeURIComponent(u.pathname.split("/").pop() || "");
        } catch {
          return decodeURIComponent((urlOrName || "").split("/").pop() || "");
        }
      }

      function guessRunFolderFromUrl(u) {
        try {
          const p = new URL(u, location.origin).pathname;
          // /output/<run>/.../results.csv
          const m1 = p.match(/\/output\/([^\/]+)\//);
          if (m1) return m1[1];
          // /download/<run>.csv or .zip
          const m2 = p.match(/\/download\/([^\/]+)\.(csv|zip)$/);
          if (m2) return m2[1];
          const base = p.split("/").pop() || "";
          const m3 = base.match(/^(.+?)\.csv$/);
          if (m3) return m3[1];
        } catch {}
        return "";
      }

      function filterRowsToRun(rows, opt, usedUrl) {
        // Try to identify the run “folder”/token from URL, zip, or name
        const runToken =
          guessRunFolderFromUrl(usedUrl) ||
          guessRunFolderFromUrl(opt?.dataset?.zip || "") ||
          guessRunFolderFromUrl(opt?.dataset?.name || "");

        if (!rows?.length || !runToken) return rows;

        // Use any of the doc paths to decide row provenance
        const filtered = rows.filter((r) => {
          const paths = [
            r.receipt_file,
            r.registration_file,
            r.cgs_file,
            r.gsc_file,
          ]
            .filter(Boolean)
            .map(String);
          return paths.some((p) => p.includes(runToken));
        });

        // If our heuristic found something, use it; otherwise keep original
        return filtered.length ? filtered : rows;
      }

      async function validateCsvBeforeUpload(file) {
        // 1) Peek at first ~100 lines to detect weird prologs/delimiter
        const text = await file.text();
        let working = text;

        // Excel sep=; directive
        const firstLine = working.split(/\r\n|\n/)[0] || "";
        let forcedDelimiter = "";
        const sepMatch = firstLine.match(/^sep=(.+)$/i);
        if (sepMatch) {
          forcedDelimiter = sepMatch[1];
          // drop the prolog line
          working = working
            .split(/\r\n|\n/)
            .slice(1)
            .join("\n");
        }

        // 2) Parse with Papa
        const parsed = Papa.parse(working, {
          header: true,
          skipEmptyLines: "greedy",
          delimiter: forcedDelimiter || "", // auto-detect unless sep= forced it
          dynamicTyping: false,
          transformHeader: (h) => (h || "").trim().toLowerCase(),
        });

        if (parsed.errors?.length) {
          const e = parsed.errors[0];
          throw new Error(
            `CSV parse error on row ${e.row ?? "?"}: ${e.message}`
          );
        }

        // 3) Header checks
        const cols = parsed.meta?.fields || [];
        if (!cols.includes("entity_name")) {
          throw new Error(
            `CSV must include a column named "entity_name". Found: ${
              cols.join(", ") || "(none)"
            }`
          );
        }
        // duplicate header detection (Papa already keeps last; we can detect by scanning raw line too)
        const rawHeader = (working.split(/\r\n|\n/)[0] || "").trim();
        const tokens = rawHeader.split(parsed.meta.delimiter || ",");
        const seen = new Set();
        for (const t of tokens.map((s) => s.trim().toLowerCase())) {
          if (seen.has(t))
            throw new Error(`Duplicate column "${t}" in header.`);
          seen.add(t);
        }

        // 4) Quick row-level hygiene
        const badRows = [];
        (parsed.data || []).forEach((row, idx) => {
          // row index +2 accounts for header line
          const lineNo = idx + 2;
          const name = (row.entity_name ?? "").toString().trim();
          if (!name) badRows.push(`Row ${lineNo}: missing entity_name`);
          // CSV injection — warn/not block
          for (const k in row) {
            const v = (row[k] ?? "").toString();
            if (/^[=+\-@]/.test(v)) {
              // mark or neutralize for later export
              row[k] = "'" + v; // prefix apostrophe
            }
          }
        });
        if (badRows.length) {
          // choose: block or allow? Here we block to be safe:
          throw new Error(
            `Found ${badRows.length} row issue(s).\n` +
              badRows.slice(0, 5).join("\n")
          );
        }

        // 5) Success — hand off normalized CSV (optionally rebuild CSV for upload)
        return { parsed, textForUpload: working };
      }

      async function fetchCsvTextWithFallbacks(opt) {
        const v = (opt.value || "").trim();
        const rawName = (opt.dataset?.name || fileBaseName(v) || "").trim();

        // If the "name" is literally "results.csv" (generic), ignore it.
        const name = rawName.toLowerCase() === "results.csv" ? "" : rawName;

        // Try concrete files FIRST, then the option URL as the last resort.
        const candidates = [
          name ? `/output/${encodeURIComponent(name)}` : "",
          name ? `/download/${encodeURIComponent(name)}` : "",
          v, // ← alias (last)
        ].filter(Boolean);

        const tried = new Set();

        for (let u of candidates) {
          if (tried.has(u)) continue;
          tried.add(u);

          // Never pull aggregated endpoints for a single-run view
          if (/\/(recent-results|latest-results)\b/.test(u)) continue;

          // add a cache-buster to dodge CDN caches
          const url = u + (u.includes("?") ? "&" : "?") + "v=" + Date.now();

          try {
            const r = await fetch(url);
            if (!r.ok) continue;

            const ct = (r.headers.get("content-type") || "").toLowerCase();
            const text = await r.text();

            // Skip aggregated/JSON payloads even if server mislabels content-type
            const looksJson =
              ct.includes("application/json") || /^\s*[\[{]/.test(text);
            if (looksJson) continue;

            // Basic CSV sanity check (avoid HTML/error pages)
            const head = text.slice(0, 400);
            const looksCsv =
              /[,;\t]/.test(head) ||
              /(^|\n)(entity|entity_name|status|filing_id|started_at)\b/i.test(
                head
              );
            const looksHtml = /<html[\s>]/i.test(head);

            if (!looksCsv || looksHtml) continue;

            console.debug("[run-select] using", u);
            return { text, usedUrl: u };
          } catch {
            // try next
          }
        }

        throw new Error("All CSV fetch attempts failed for this run");
      }

      async function loadCombinedClient(days = RECENT_DAYS) {
        // 1) Get the list of run CSVs for the window
        let runs = [];
        try {
          runs = await fetch(
            `/result-files?days=${encodeURIComponent(days)}`
          ).then((r) => r.json());
        } catch (e) {
          console.warn("result-files failed", e);
        }
        if (!Array.isArray(runs) || runs.length === 0) {
          // nothing to combine -> fall back to latest
          await loadLatestResults();
          return;
        }

        // 2) Fetch & parse all CSVs
        const csvs = await Promise.all(
          runs.map(async (r) => {
            try {
              const txt = await fetch(r.url).then((x) => {
                if (!x.ok) throw new Error("CSV fetch failed " + r.url);
                return x.text();
              });
              const parsed = Papa.parse(txt, {
                header: true,
                skipEmptyLines: true,
              });
              const rows = Array.isArray(parsed.data) ? parsed.data : [];
              // Tag the source (optional, useful for debugging)
              rows.forEach((row) => {
                row.__run_label = r.label || "";
              });
              return rows;
            } catch (e) {
              console.warn("Failed one CSV:", r.url, e);
              return [];
            }
          })
        );

        // 3) Flatten
        let allRows = csvs.flat();

        // 4) Dedupe (entity + filing_id + started_at is a good-enough key)
        const seen = new Set();
        allRows = allRows.filter((r) => {
          const k = [
            (r.entity_name || r.entity || "").trim().toLowerCase(),
            (r.filing_id || "").trim(),
            (r.started_at || "").trim(),
          ].join("|");
          if (seen.has(k)) return false;
          seen.add(k);
          return true;
        });

        // 5) Sort desc by started_at (fallback to keep stable order)
        const toTime = (s) => {
          if (!s) return 0;
          // tolerate "YYYY-MM-DD HH:mm:ss" by replacing space with 'T'
          const isoish = s.includes("T") ? s : s.replace(" ", "T");
          const t = Date.parse(isoish);
          return isNaN(t) ? 0 : t;
        };
        allRows.sort((a, b) => toTime(b.started_at) - toTime(a.started_at));

        // 6) Render and update stats
        renderResultsRows(allRows);
        updateStatsFromRows(allRows);

        // Combined view shouldn't show per-run downloads
        const dlCsv = document.getElementById("runDownloadCsv");
        const dlZip = document.getElementById("runDownloadZip");
        dlCsv.classList.add("hidden");
        dlCsv.removeAttribute("href");
        dlZip.classList.add("hidden");
        dlZip.removeAttribute("href");
      }

      async function loadLatestResults() {
        try {
          const meta = await fetch("/latest-results").then((r) => r.json());
          if (!meta.file) {
            resBody.innerHTML = "";
            resCount.textContent = "0 rows";
            statDone.textContent = "0";
            statErr.textContent = "0";
            statAvg.textContent = "—";
            return;
          }
          const csvText = await fetch(meta.file).then((r) => r.text());
          const parsed = Papa.parse(csvText, {
            header: true,
            skipEmptyLines: true,
          });
          const rows = parsed.data || [];

          resBody.innerHTML = rows
            .map((r) => {
              const recP = toWeb(r.receipt_file || "");
              const regP = toWeb(r.registration_file || "");
              const cgsP = toWeb(r.cgs_file || "");
              const gscP = toWeb(r.gsc_file || "");

              const rec = recP ? docPill(recP, "Receipt", "slate") : "";
              const reg = regP ? docPill(regP, "Registration", "indigo") : "";
              const cgs = cgsP ? docPill(cgsP, "CGS", "violet") : "";
              const gsc = gscP ? docPill(gscP, "GSC", "cyan") : "";

              const docs =
                [rec, reg, cgs, gsc].filter(Boolean).join(pillSep()) || "—";

              const note = cleanNote(r.notes);
              const ent = cleanEntity(r.entity_name || r.entity || "—");

              return `
                <tr class="hover:bg-gray-50">
                    <td class="px-3 py-2 text-gray-500 tabular-nums">${escapeHtml(
                      r.started_at || "—"
                    )}</td>
                    <td class="px-3 py-2 text-left font-medium whitespace-normal break-words [overflow-wrap:anywhere]">${escapeHtml(
                      ent
                    )}</td>
                    <td class="px-3 py-2">${badge(r.status)}</td>
                    <td class="px-3 py-2">${escapeHtml(r.filing_id || "—")}</td>
                    <td class="px-3 py-2">
                    <div class="flex flex-wrap gap-1 items-center">${docs}</div>
                    </td>
                    <td class="px-3 py-2 text-gray-700 text-left whitespace-normal break-words">
                    ${note ? escapeHtml(note) : "—"}
                    </td>
                </tr>`;
            })
            .join("");
          resCount.textContent = `${rows.length} row${
            rows.length === 1 ? "" : "s"
          }`;
          const done = rows.filter(
            (r) => (r.status || "").toUpperCase() === "SUCCESS"
          ).length;
          const errs = rows.filter(
            (r) => (r.status || "").toUpperCase() === "ERROR"
          ).length;
          statDone.textContent = done;
          statErr.textContent = errs;

          const durations = rows
            .map((r) => parseFloat(r.elapsed_s || "0"))
            .filter((x) => !isNaN(x) && x > 0);
          if (durations.length) {
            const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
            const mm = String(Math.floor(avg / 60)).padStart(2, "0");
            const ss = String(Math.floor(avg % 60)).padStart(2, "0");
            statAvg.textContent = `${mm}:${ss}`;
          } else {
            statAvg.textContent = "—";
          }
        } catch {}
      }

      async function stopRun(soft = true) {
        await fetch(soft ? "/stop-run" : "/stop-run-now", { method: "POST" });
      }

      exportMenuBtn?.addEventListener("click", () => {
        const open = exportMenuPanel.classList.toggle("hidden");
        exportMenuBtn.setAttribute("aria-expanded", (!open).toString());
      });

      // Upload CSV (auto-start)
      csvInput.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;

        if (isRunning) {
          alert(
            "A run is already in progress. Stop it before uploading a new CSV."
          );
          e.target.value = "";
          return;
        }

        csvName.textContent = file.name;

        // reset stats for a new batch
        doneCount = 0;
        errCount = 0;
        statDone.textContent = "0";
        statErr.textContent = "0";

        const fd = new FormData();
        fd.append("file", file, file.name);

        validateCsvBeforeUpload(file);

        const res = await fetch("/upload-csv", { method: "POST", body: fd });
        if (!res.ok) {
          alert("Upload failed.");
          return;
        }
        const data = await res.json();

        // after successful /upload-csv
        queueRows = (data.preview || []).map((r) => ({
          ...r,
          registered_agent_name:
            r.registered_agent_name || DEFAULTS.registered_agent_name,
        }));
        renderQueue(queueRows);
        statQueued.textContent = queueRows.length;

        currentCsvPath = data.csv_path;
        btnStart.disabled = false; // <-- user must click Start
        btnStart.classList.remove("hidden"); // make sure visible

        liveLog.textContent = "";
        afterRunLinks.innerHTML = "";

        e.target.value = "";
      });

      // Manual Start (optional)
      btnStart.addEventListener("click", () => {
        if (!currentCsvPath || isRunning) return;

        if (sse) {
          try {
            sse.close();
          } catch {}
        }
        liveLog.textContent = "";
        afterRunLinks.innerHTML = "";

        clearTimeline();

        // reset stats
        doneCount = 0;
        errCount = 0;
        statDone.textContent = "0";
        statErr.textContent = "0";

        // show temporary queue placeholder, etc...
        clearQueueUI();
        queueBody.innerHTML = `
      <tr><td colspan="5" class="px-3 py-3 text-sm text-slate-500">
      Preparing queue…
      </td></tr>
  `;
        statQueued.textContent = "—";

        setRunning(true);

        sse = new EventSource(
          `/run?csv_path=${encodeURIComponent(currentCsvPath)}`
        );
        wireEventStream(sse);
      });

      btnStop.addEventListener("click", async () => {
        btnStop.disabled = true;
        btnStop.querySelector("span").textContent = "Stopping…";
        runStatus.textContent = "Stopping…";
        runStatus.className =
          "inline-flex items-center rounded-full px-3 py-1 text-xs font-medium bg-amber-100 text-amber-700";
        try {
          await stopRun(true);
        } catch {}
      });

      btnStop.addEventListener("mousedown", () => {
        if (btnStop.disabled) return;
        _pressTimer = setTimeout(async () => {
          if (
            confirm("Force stop immediately? Current entity may be partial.")
          ) {
            btnStop.disabled = true;
            runStatus.textContent = "Stopping now…";
            runStatus.className =
              "inline-flex items-center rounded-full px-3 py-1 text-xs font-medium bg-rose-100 text-rose-700";
            await stopRun(false); // hard stop
          }
        }, 800);
      });
      ["mouseup", "mouseleave"].forEach((evt) =>
        btnStop.addEventListener(evt, () => clearTimeout(_pressTimer))
      );

      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && !btnStop.disabled) btnStop.click();
      });

      // Clear log
      btnClear.addEventListener("click", () => {
        liveLog.textContent = "";
      });

      refreshRunsBtn?.addEventListener("click", () => {
        populateRunDropdown(RECENT_DAYS, true);
      });

      // --- On load: reattach to live tail and rebuild queue
      (async function boot() {
        try {
          setupTimelineAutoscroll();
          const ar = await fetch("/active-run").then((r) => r.json());
          if (ar && ar.running && ar.run_id) {
            setRunning(true);

            // 1/3: figure out csv path to rebuild queue
            let csvPath = ar.csv_path;
            if (!csvPath) {
              try {
                const meta = await fetch(`/run-meta/${ar.run_id}`).then((r) =>
                  r.json()
                );
                csvPath = meta.csv_path;
              } catch {}
            }

            // 2/3: ask the server for a queue snapshot right now
            if (csvPath) {
              const qp = await fetch(
                `/queue-preview?csv_path=${encodeURIComponent(
                  csvPath
                )}&run_id=${encodeURIComponent(ar.run_id)}`
              ).then((r) => r.json());
              queueRows = qp.preview || [];
              renderQueue(queueRows);
              document.getElementById("statQueued").textContent =
                qp.remaining ?? queueRows.length;
              if (qp.current_idx) highlightQueueRow(qp.current_idx - 1);

              // start polling the queue (keeps “Queued” + table fresh during the run)
              startQueuePolling(csvPath, ar.run_id);
            }

            // 3/3: reattach to live log tail
            if (sse)
              try {
                sse.close();
              } catch {}
            sse = new EventSource(`/stream/${ar.run_id}`);
            wireEventStream(sse);

            await populateRunDropdown();
          } else {
            setRunning(false);
            await populateRunDropdown();
            stopQueuePolling();
          }
        } catch {
          setRunning(false);
          await populateRunDropdown();
          stopQueuePolling();
        }
      })();
    </script>
  </body>
</html>
